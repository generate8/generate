/**
 * @typedef {import('./generators').Gen} Gen
 */

/**
 * generator list, array version
 * @param {(gen: Gen) => boolean} shouldGeneratorBeRemovedFn
 * @param {(x: Gen, y: Gen) => boolean} isXABetterGeneratorThanYFn
 * @param {() => Gen[]} newGeneratorsFn
 * @param {any} isSpliceFast
 * @param {any} useAwait_
 * @param {null|((gen:Gen)=>void)} beforeGeneratorIsUsedFn
 * @param {null|((gen: Gen)=>void)} onGeneratorExhaustedFn
 * @param {null|((gen:Gen,thisGeneratorMustBeConsidered:boolean)=>boolean)} generatorToUseFilterFn
 */
export async function initGenerators(
  shouldGeneratorBeRemovedFn,
  isXABetterGeneratorThanYFn,
  newGeneratorsFn,
  isSpliceFast,
  useAwait_,
  beforeGeneratorIsUsedFn,
  onGeneratorExhaustedFn,
  generatorToUseFilterFn
) {
  generatorToUseFilter = generatorToUseFilterFn;
  onGeneratorExhausted = onGeneratorExhaustedFn;
  shouldGeneratorBeRemoved = shouldGeneratorBeRemovedFn;
  isXBetterGeneratorThanY = isXABetterGeneratorThanYFn;
  newGenerators = newGeneratorsFn;
  if (newGenerators) {
    generators = newGenerators();
  } else {
    generators = [];
  }
  isSpliceFast_ = isSpliceFast;
  useAwait = useAwait_;
  beforeGeneratorIsUsed = beforeGeneratorIsUsedFn;
}

/**
 * @type {((gen:Gen,thisGeneratorMustBeConsidered:boolean) => boolean) | null}
 */
let generatorToUseFilter;

export async function generate() {
  /** @type {Gen} */
  let generator = cacheForFirstGenerator
    ? cacheForFirstGenerator
    : await generators[0];
  let idx = 0;
  if (generatorToUseFilter) {
    while (!generatorToUseFilter(generator, false)) {
      idx++;
      if (idx == generators.length) {
        idx = 0;
        generator = generators[idx];
        generatorToUseFilter(generator, true);
        break;
      }
      generator = generators[idx];
    }
  }
  beforeGeneratorIsUsed && beforeGeneratorIsUsed(generator);
  const generated = generator.next().value;
  if (generated == null) {
    //console.log("nothing (further) was generated by this generator!!!");
    const exhaustedGenerator = await generators.shift();
    cacheForFirstGenerator = null;
    onGeneratorExhausted && onGeneratorExhausted(exhaustedGenerator);
  }
  return generated;
}

/** @type {null|((gen: Gen)=>void)} */
let onGeneratorExhausted = null;

export async function removeUnwantedGenerators() {
  cacheForFirstGenerator = null;
  if (!isSpliceFast_) {
    const newArray = newGenerators ? newGenerators() : [];
    const length = generators.length;
    for (let idx = 0; idx < length; idx++) {
      const generator = useAwait ? await generators[idx] : generators[idx];
      if (!shouldGeneratorBeRemoved(generator)) {
        await newArray.push(generator);
      } else {
        onGeneratorExhausted && onGeneratorExhausted(generator);
      }
    }
    generators = newArray;
  } else {
    let idx = 0;
    while (idx < generators.length) {
      const generator = await generators[idx];
      if (shouldGeneratorBeRemoved(generator)) {
        await generators.splice(idx, 1);
        onGeneratorExhausted && onGeneratorExhausted(generator);
        continue;
      }
      idx++;
    }
  }
}

/**
 * @param {any} generator
 */
export async function addGenerator(generator) {
  const len = generators.length;
  if (len == 0) {
    //todo: tmp: remove below
    assert(/** @type {any} */ (generator).state.errors != null);
    await generators.push(generator);
    return;
  }
  await addGenerator2(generator, 0, len - 1);
}

/**
 * @param {any} generator
 * @param {number} upperIndexInclusive
 * @param {number} lowerIndexInclusive
 */
async function addGenerator2(
  generator,
  upperIndexInclusive,
  lowerIndexInclusive
) {
  while (true) {
    //assert(upperIndexInclusive<=lowerIndexInclusive)
    if (
      isXBetterGeneratorThanY(generator, await generators[upperIndexInclusive])
    ) {
      await generators.splice(upperIndexInclusive, 0, generator);
      return;
    }
    if (
      isXBetterGeneratorThanY(await generators[lowerIndexInclusive], generator)
    ) {
      await generators.splice(lowerIndexInclusive + 1, 0, generator);
      return;
    }
    if (upperIndexInclusive == lowerIndexInclusive) {
      // as good as each other, put the newest one after:
      await generators.splice(lowerIndexInclusive + 1, 0, generator);
      return;
    }
    let midIndexInclusive = Math.ceil(
      (upperIndexInclusive + lowerIndexInclusive) / 2
    );
    //--assert(upperIndexInclusive<midIndexInclusive)
    //--assert(midIndexInclusive<=lowerIndexInclusive)
    if (
      isXBetterGeneratorThanY(generator, await generators[midIndexInclusive])
    ) {
      lowerIndexInclusive = midIndexInclusive - 1;
      //assert(upperIndexInclusive<=lowerIndexInclusive)
      continue;
    }
    upperIndexInclusive = midIndexInclusive;
    //assert(upperIndexInclusive<=lowerIndexInclusive)
  }
}

export function numOfGenerators() {
  return generators.length;
}

/**
 * @type {any[]}
 */
let generators = [];

/**
 * @type {(gen: Gen) => boolean}
 */
let shouldGeneratorBeRemoved;

/**
 * @type {(x: Gen, y: Gen) => boolean}
 */
let isXBetterGeneratorThanY;

/**
 * @type {() => Gen[]}
 */
let newGenerators;

/**
 * @type {any}
 */
let isSpliceFast_;

/**
 * @type {null}
 */
let cacheForFirstGenerator;

/**
 * @type {any}
 */
let useAwait;

/**
 * @type {((gen: Gen) => void) | null}
 */
let beforeGeneratorIsUsed;

// TODO: comment out calls to this once sure
/**
 * @param {boolean} x
 */
function assert(x) {
  if (!x) {
    debugger;
    throw new Error("assertion failed");
  }
}

export function dbgCheckGenOrder() {
  let idx = -1;
  for (const generator of generators) {
    idx++;
    if (idx == 50) {
      break;
    }
    if (idx > 0) {
      const prevGenerator = generators[idx - 1];
      assert(!isXBetterGeneratorThanY(prevGenerator, generator));
    }
  }
}
